.LOG
mysqldump -uroot -p --databases databasename >dump.sql 数据库备份
mysqldump -uroot -p --databases database.table >dump.sql 数据库表备份
16:45 2017/8/21
主从复制的服务器配置
1.主服务器
log-bin=mysql-bin
sever-id=**
2.从服务器
log-bin=mysql-bin
sever-id=**
3.重启两台服务器的mysql
4.主服务器建立授权
grant replication slave on *.* to 'username'@'host' identified by 'password';
5.show master status;记录master_log_file,master_log_pos
6.stop slave 
change master to master_host='192.168.203.129',master_user='mysync',master_password='q123456',master_log_file='mysql-bin.000017',master_log_pos=107;
start slave
7.show slave status
9:04 2017/8/22

14:50 2017/8/31
临时开启通用查询日志
set global general_log='on';
explain extended
show warnings
perror 错误号
show status like 'handler%';检查是否使用了索引
13:12 2017/9/4

权限授予
'GRANT ALL PRIVILEGES ON `indu_program`.* TO \'credit_l\'@\'%\''
'GRANT USAGE ON *.* TO \'credit_l\'@\'%\' IDENTIFIED BY PASSWORD \'*3100D4383269AAD781A4483B928CF9BDB8AC53C5\''

权限移除
#给用户cacti赋予所有库的所有权限  
GRANT ALL PRIVILEGES ON *.* TO 'cacti'@'%' IDENTIFIED BY 'cacti' WITH GRANT OPTION;  
#重新载入赋权表  
FLUSH PRIVILEGES;  
  
#收回权限(不包含赋权权限)  
REVOKE ALL PRIVILEGES ON *.* FROM cacti;  
REVOKE ALL PRIVILEGES ON cacti.* FROM cacti;  
#收回赋权权限  
REVOKE GRANT OPTION ON *.* FROM cacti;  
#重新载入赋权表  
FLUSH PRIVILEGES;  
14:14 2017/9/8


二进制命令
二进制日志（binary log）记录了对MySQL数据库执行更改的所有操作，但是不包括SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改。然而，若操作本身并没有导致数据库发生变化，那么该操作可能也会写入二进制日志。
SHOW BINLOG EVENTS IN 'mysql-bin.000001'
13:26 2017/9/15

sql_mode
解析
这个sql_mode,简而言之就是：它定义了你MySQL应该支持的sql语法，对数据的校验等等。。
一、如何查看当前数据库使用的sql_mode：
select @@sql_mode;  
二、sql_mode值的含义：
ONLY_FULL_GROUP_BY：
对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么将认为这个SQL是不合法的，因为列不在GROUP BY从句中
STRICT_TRANS_TABLES：
在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做任何限制
NO_ZERO_IN_DATE：
在严格模式，不接受月或日部分为0的日期。如果使用IGNORE选项，我们为类似的日期插入'0000-00-00'。在非严格模式，可以接受该日期，但会生成警告。
NO_ZERO_DATE：
在严格模式，不要将 '0000-00-00'做为合法日期。你仍然可以用IGNORE选项插入零日期。在非严格模式，可以接受该日期，但会生成警告
ERROR_FOR_DIVISION_BY_ZERO：
在严格模式，在INSERT或UPDATE过程中，如果被零除(或MOD(X，0))，则产生错误(否则为警告)。如果未给出该模式，被零除时MySQL返回NULL。如果用到INSERT IGNORE或UPDATE IGNORE中，MySQL生成被零除警告，但操作结果为NULL。
NO_AUTO_CREATE_USER
防止GRANT自动创建新用户，除非还指定了密码。
NO_ENGINE_SUBSTITUTION：
如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常
三、据说是MySQL5.0以上版本支持三种sql_mode模式：ANSI、TRADITIONAL和STRICT_TRANS_TABLES。 
1、ANSI模式：宽松模式，更改语法和行为，使其更符合标准SQL。对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，报warning警告。对于本文开头中提到的错误，可以先把sql_mode设置为ANSI模式，这样便可以插入数据，而对于除数为0的结果的字段值，数据库将会用NULL值代替。
将当前数据库模式设置为ANSI模式：
 set @@sql_mode=ANSI;  
2、TRADITIONAL模式：严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误，而不仅仅是警告。用于事物时，会进行事物的回滚。 注释：一旦发现错误立即放弃INSERT/UPDATE。如果你使用非事务存储引擎，这种方式不是你想要的，因为出现错误前进行的数据更改不会“滚动”，结果是更新“只进行了一部分”。
将当前数据库模式设置为TRADITIONAL模式：
 set @@sql_mode=TRADITIONAL;   
 3、STRICT_TRANS_TABLES模式：严格模式，进行数据的严格校验，错误数据不能插入，报error错误。如果不能将给定的值插入到事务表中，则放弃该语句。对于非事务表，如果值出现在单行语句或多行语句的第1行，则放弃该语句。
将当前数据库模式设置为STRICT_TRANS_TABLES模式：
 set @@sql_mode=STRICT_TRANS_TABLES;  
另外说一点，这里的更改数据库模式都是session级别的，一次性，关了再开就不算数了！！！
也可以通过配置文件设置:vim /etc/my.cnf
在my.cnf（my.ini）添加如下配置:
[mysqld]
sql_mode='你想要的模式'